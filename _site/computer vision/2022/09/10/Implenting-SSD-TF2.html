<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Implementing a Single Shot Detector Model in Tensorflow 2.0 &middot; UR Machine Learning Blog
    
  </title>

  


  <!-- CSS -->
  <link rel="stylesheet" href="/urmlblog/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
<!--  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/urmlblog/favicon.png" />
<link rel="shortcut icon" href="/urmlblog/favicon.ico" />-->

  <!-- RSS -->
<!--  <link rel="alternate" type="application/rss+xml" title="RSS" href="/urmlblog/feed.xml" />-->

  <!-- Additional head bits without overriding original head -->
</head>


  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "all" } }
  });
  MathJax.Hub.Config({ TeX: { extensions: ["color.js"] }});
<!--  MathJax.Hub.Config({-->
<!--    jax: ["input/TeX","output/HTML-CSS"],-->
<!--    displayAlign: "left"-->
<!--  });-->
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/urmlblog/favicon.png" />
<link rel="shortcut icon" href="/urmlblog/favicon.ico" />

  <body class="post">

    <div id="sidebar">
  <header>
    <div class="site-title">
      <a href="/urmlblog/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        UR Machine Learning Blog
      </a>
    </div>
    <p class="lead">Data Scientist at City of Edmonton</p>
  </header>
  <nav id="sidebar-nav-links">
  
    <a class="home-link "
        href="/urmlblog/">Home</a>
  
  

  

  


  
    
  

  
    
      <a class="page-link "
          href="/urmlblog/about.html">About</a>
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  

  

  
    
  

  
    
  

  

  


  


  
    
  

  
    
  

  
    
      <a class="category-link "
          href="/urmlblog/category/categories.html">Categories</a>
    
  

  
    
  

  

  
    
  

  
    
  

  

  

  
    
  

  
    
  

  

  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">
  

<!--  <a id="subscribe-link"-->
<!--     class="icon" title="Subscribe" aria-label="Subscribe"-->
<!--     href="/urmlblog/feed.xml">-->
<!--    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>-->
<!--  </a>-->

  
  
  
  

  <a id="linkedin-link"
       title="Linkedin" aria-label="linkedin" class="icon" target="_blank"
       href="https://www.linkedin.com/in/usman-rizwan-data-magic/">
      <?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24pt" height="24pt" viewBox="0 0 24 24" version="1.1">
<defs>
<filter id="alpha" filterUnits="objectBoundingBox" x="0%" y="0%" width="100%" height="100%">
  <feColorMatrix type="matrix" in="SourceGraphic" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"/>
</filter>
<mask id="mask0">
  <g filter="url(#alpha)">
<rect x="0" y="0" width="24" height="24" style="fill:rgb(0%,0%,0%);fill-opacity:0.780392;stroke:none;"/>
  </g>
</mask>
<linearGradient id="linear0" gradientUnits="userSpaceOnUse" x1="-808.8727" y1="199.8918" x2="-860.5692" y2="49.2029" gradientTransform="matrix(-0.0554531,0,0,-0.0554531,-38.267222,8.831372)">
<stop offset="0" style="stop-color:rgb(100%,100%,100%);stop-opacity:1;"/>
<stop offset="1" style="stop-color:rgb(100%,100%,100%);stop-opacity:0;"/>
</linearGradient>
<clipPath id="clip1">
  <rect width="24" height="24"/>
</clipPath>
<g id="surface6" clip-path="url(#clip1)">
<path style=" stroke:none;fill-rule:nonzero;fill:url(#linear0);" d="M 17.195312 1.925781 L 6.804688 1.925781 C 4.054688 1.925781 1.839844 4.160156 1.839844 6.929688 L 1.839844 17.070312 C 1.929688 19.234375 2.273438 17.863281 2.921875 15.46875 C 3.679688 12.683594 6.148438 10.246094 9.152344 8.421875 C 11.445312 7.03125 14.011719 6.140625 18.683594 6.054688 C 21.335938 6.007812 21.101562 2.617188 17.195312 1.925781 Z M 17.195312 1.925781 "/>
</g>
</defs>
<g id="surface1">
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(11.372549%,54.901961%,70.980392%);fill-opacity:1;" d="M 19.6875 0.984375 L 4.3125 0.984375 C 2.472656 0.984375 0.984375 2.472656 0.984375 4.3125 L 0.984375 19.6875 C 0.984375 21.527344 2.472656 23.015625 4.3125 23.015625 L 19.6875 23.015625 C 21.527344 23.015625 23.015625 21.527344 23.015625 19.6875 L 23.015625 4.3125 C 23.015625 2.472656 21.527344 0.984375 19.6875 0.984375 Z M 19.6875 0.984375 "/>
<use xlink:href="#surface6" mask="url(#mask0)"/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" d="M 7.648438 19.476562 L 7.648438 9.515625 L 4.339844 9.515625 L 4.339844 19.476562 Z M 5.996094 8.15625 C 7.148438 8.15625 7.867188 7.390625 7.867188 6.433594 C 7.847656 5.457031 7.148438 4.710938 6.015625 4.710938 C 4.882812 4.710938 4.144531 5.457031 4.144531 6.433594 C 4.144531 7.390625 4.863281 8.15625 5.972656 8.15625 Z M 5.996094 8.15625 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" d="M 9.484375 19.476562 L 12.792969 19.476562 L 12.792969 13.914062 C 12.792969 13.617188 12.816406 13.320312 12.902344 13.105469 C 13.144531 12.511719 13.6875 11.894531 14.601562 11.894531 C 15.800781 11.894531 16.28125 12.808594 16.28125 14.148438 L 16.28125 19.476562 L 19.589844 19.476562 L 19.589844 13.765625 C 19.589844 10.703125 17.957031 9.28125 15.777344 9.28125 C 13.992188 9.28125 13.207031 10.277344 12.773438 10.960938 L 12.792969 10.960938 L 12.792969 9.515625 L 9.484375 9.515625 C 9.527344 10.449219 9.484375 19.476562 9.484375 19.476562 Z M 9.484375 19.476562 "/>
</g>
</svg>

    </a>

    <a id="github-link"
       title="Github" aria-label="github" class="icon" target="_blank"
       href="https://github.com/usmanr149/">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 28" height="24" width="28"><path d="M12 2c6.625 0 12 5.375 12 12 0 5.297-3.437 9.797-8.203 11.391-0.609 0.109-0.828-0.266-0.828-0.578 0-0.391 0.016-1.687 0.016-3.297 0-1.125-0.375-1.844-0.812-2.219 2.672-0.297 5.484-1.313 5.484-5.922 0-1.313-0.469-2.375-1.234-3.219 0.125-0.313 0.531-1.531-0.125-3.187-1-0.313-3.297 1.234-3.297 1.234-0.953-0.266-1.984-0.406-3-0.406s-2.047 0.141-3 0.406c0 0-2.297-1.547-3.297-1.234-0.656 1.656-0.25 2.875-0.125 3.187-0.766 0.844-1.234 1.906-1.234 3.219 0 4.594 2.797 5.625 5.469 5.922-0.344 0.313-0.656 0.844-0.766 1.609-0.688 0.313-2.438 0.844-3.484-1-0.656-1.141-1.844-1.234-1.844-1.234-1.172-0.016-0.078 0.734-0.078 0.734 0.781 0.359 1.328 1.75 1.328 1.75 0.703 2.141 4.047 1.422 4.047 1.422 0 1 0.016 1.937 0.016 2.234 0 0.313-0.219 0.688-0.828 0.578-4.766-1.594-8.203-6.094-8.203-11.391 0-6.625 5.375-12 12-12zM4.547 19.234c0.031-0.063-0.016-0.141-0.109-0.187-0.094-0.031-0.172-0.016-0.203 0.031-0.031 0.063 0.016 0.141 0.109 0.187 0.078 0.047 0.172 0.031 0.203-0.031zM5.031 19.766c0.063-0.047 0.047-0.156-0.031-0.25-0.078-0.078-0.187-0.109-0.25-0.047-0.063 0.047-0.047 0.156 0.031 0.25 0.078 0.078 0.187 0.109 0.25 0.047zM5.5 20.469c0.078-0.063 0.078-0.187 0-0.297-0.063-0.109-0.187-0.156-0.266-0.094-0.078 0.047-0.078 0.172 0 0.281s0.203 0.156 0.266 0.109zM6.156 21.125c0.063-0.063 0.031-0.203-0.063-0.297-0.109-0.109-0.25-0.125-0.313-0.047-0.078 0.063-0.047 0.203 0.063 0.297 0.109 0.109 0.25 0.125 0.313 0.047zM7.047 21.516c0.031-0.094-0.063-0.203-0.203-0.25-0.125-0.031-0.266 0.016-0.297 0.109s0.063 0.203 0.203 0.234c0.125 0.047 0.266 0 0.297-0.094zM8.031 21.594c0-0.109-0.125-0.187-0.266-0.172-0.141 0-0.25 0.078-0.25 0.172 0 0.109 0.109 0.187 0.266 0.172 0.141 0 0.25-0.078 0.25-0.172zM8.937 21.438c-0.016-0.094-0.141-0.156-0.281-0.141-0.141 0.031-0.234 0.125-0.219 0.234 0.016 0.094 0.141 0.156 0.281 0.125s0.234-0.125 0.219-0.219z"></path>
</svg>

    </a>

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/urmlblog/tags.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  
    <a id="search-link"
       class="icon"
       title="Search" aria-label="Search"
       href="/urmlblog/search.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
    </a>
  

  <!-- Optional additional links to insert for icons links -->
</nav>

  <!--<p>-->
<!--  &copy; 2022.-->
<!--  <a href="/urmlblog/LICENSE.md">MIT License.</a>-->
<!--</p>-->

</div>

    <main class="container">
      <header>
  <h1 class="post-title">Implementing a Single Shot Detector Model in Tensorflow 2.0</h1>
</header>
<div class="content">
  <div class="post-meta">
  <span class="post-date">10 Sep 2022</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        Computer Vision
      
    
  </span>
</div>


  <div class="post-body">
    <p>Single Shot MultiBox Detector (SSD) detects objects in images using a single deep neural network. In this blog post I will cover how to implement SSD300 (meaning images are scaled to 300x300 before being fed to the model) detector presented <a href="https://arxiv.org/pdf/1512.02325.pdf" target="_blank">here</a> in Tensorflow 2.0.</p>

<h1 id="what-do-we-need">What do we Need?</h1>

<p>To train an SSD model, we need an input image with ground truth boxes for each objects. The figure below shows an example of an image with a ground truth label for aeroplane:</p>

<p><img src="/urmlblog/images/SSD/image_w_bbox.png" alt="_config.yml" /></p>

<p>In addition we also need default boxes (also called <a href="https://usmanr149.github.io/urmlblog/computer%20vision/2022/09/09/SSD-Anchorboxes.html" target="_blank">anchor boxes</a>). At training time, the default boxes are matched to the ground truth boxes. The image below shows all of the default boxes that overlap with the ground truth box.</p>

<p><img src="/urmlblog/images/SSD/default_boxes_w_IOU_g_0.5.png" alt="_config.yml" /></p>

<p>The matched boxes are treated as positives and the rest of the default boxes are treated as negative.</p>

<h2 id="model-configuration">Model Configuration</h2>

<p>The SSD approach produces a fixed-size collection of default boxes. The model then predict the offset and classification scores for each of the default boxes. The early network layers are based on standard architecture used for image classification (<a href="https://keras.io/api/applications/vgg/" target="_blank">VGG16</a>, <a href="https://keras.io/api/applications/vgg/" target="_blank">VGG19</a>, <a href="https://keras.io/api/applications/mobilenet/" target="_blank">MobileNetV1</a>, <a href="https://keras.io/api/applications/mobilenet/" target="_blank">MobileNetV2</a>, etc.). Auxilary structure is added to the base model to produce the offset and classification scores for the default boxes.  In this blog I will be going over how to use VGG16 as the base model layer and build a SSD model off off it.</p>

<p><img src="/urmlblog/images/SSD/VGG-16-SSD.png" alt="_config.yml" /></p>

<p>In SSD, the tiles of convolution kernels map to the default boxes. The goal is to predict the offsets of the default boxes and the class scores. In the image below, we can see how the CNN output maps to the default boxes for an image.</p>

<p><img src="/urmlblog/images/SSD/Default_Boxes_and_CNN_outputs.png" alt="_config.yml" /></p>

<p>For each default box we generate $(4 + c + 1)$ outputs, where 4 because of the offsets, $c$ is the number of classes in the dataset and +1 for background. To detect an object at muliple scales within a dataset SSD uses multi-scale feature maps for detections at multiple scales.</p>

<h2 id="matching-default-boxes-to-ground-truth-boxes">Matching Default Boxes to Ground Truth Boxes</h2>

<p>To train the model we need to determine which default boxes correspond to ground truth detection. Each ground truth box is matched to the default box with the highest Intersect over Union (IOU). We then also match default boxes to any ground truth boxes with IOU &gt; threshold (set as 0.5).</p>

<h2 id="training-objectives">Training Objectives</h2>

<p>The loss function for the SSD model is the weighted sum of the localization loss and the confidence loss:</p>

\[L(x, c, l, g) = \dfrac{1}{N}(L_{conf}(x,x) + \alpha L_{loc}(x,l,g))\]

<p>where</p>

<ul>
  <li>$N$ is the total number of matched default boxes, edge case: if N = 0 then set loss to 0,</li>
  <li>$x$ is an indicator for matching the $i$-th default boxes to the $j$-th ground truth box,</li>
  <li>$l$ is the predicted box,</li>
  <li>$g$ is the ground truth box,</li>
  <li>$c$ is the predicted class,</li>
  <li>$\alpha$ is set to 1.</li>
</ul>

<p>For the localization loss we regress to offsets for the $(cx, cy, w, h)$ of the matching default bounding boxes.</p>

\[L_{loc}(x,l,g) = x_{ij}^p\sum^N_{i \in Pos} \sum_{m \in \{cx, cy,w,h \}}smooth_{\text{L1}}(l_i^m - \hat{g}_j^m)\]

<p>where</p>

\[\hat{g}_j^{cx} = 5 * \dfrac{g_j^{cx} - d_i^{cx}}{d_i^w} \\
\hat{g}_j^{cy} = 5 * \dfrac{g_j^{cy} - d_i^{cy}}{d_i^h} \\
\hat{g}_j^{w} = 10 * \text{log}\left(\dfrac{g_j^w}{d_i^w}\right) \\
\hat{g}_j^{h} = 10 * \text{log}\left(\dfrac{g_j^h}{d_i^h}\right) \label{eq:offsets}\]

<p>and</p>

\[x_{ij}^p = \begin{cases}
1, ~~~ \text{if IOU &gt; threshold between default box } i \text{ and ground truth box } j \text{ on class } p \\
0, ~~~ \text{otherwise}
\end{cases}\]

<p>The prior variances or the scaling constants (5 and 10 in Eq. \ref{eq:offsets}) are not mentioned in the paper, but they are used in the code, I read about them <a href="https://jany.st/post/2017-11-05-single-shot-detector-ssd-from-scratch-in-tensorflow.html" target="_blank">here</a>. The author of the paper suggests in a github comment that they can also be understood as loss smoothing factors, the confidence and the localization loss are on a different scale and using the scaling constants brings these two losses together allowing for a smoother loss function that is easier to optimize.</p>

<p>The confidence loss is the softmax loss over multiple classes:</p>

\[L_{conf}(x,c) = -\sum_{i \in Pos}^N x_{ij}^p log(\hat{c}_i^p) - \sum_{i \in Neg}log(\hat{c}_i^0) \\
\hat{c}_i^p = \dfrac{ e^{c_i^p} }{ \sum_p e^{c_i^p} }\]

<p>where $\hat{c}_i^p$ is the predicted softmax probaility for the default box $i$, $\hat{c}_i^0$ is the predicted softmax probaility that that the default box is a background.</p>

<h2 id="implementing-ssd-in-tensorflow-20">Implementing SSD in Tensorflow 2.0</h2>

<p>Now that we have an understanding of the theory behind SSD model architecture, we can now implement the model in Tensorflow 2.0. I have already covered how to generate anchor boxes in a <a href="https://usmanr149.github.io/urmlblog/computer%20vision/2022/09/09/SSD-Anchorboxes.html" target="_blank">previous post</a> so I will not go over them here. Once we have the default boxes we can then match these default boxes with the ground truth boxes. One thing to note is that the method to generate default boxes covered in my previous blogs outputs the boxes in centroid representation: $[cx, cy, w, h]$, to calculate IOUs between two rectangles it is best to represent to use the corners representation: $[xmin, ymin, xmax, ymax]$.</p>

<p><img src="/urmlblog/images/SSD/Centroid Representation.jpg" alt="_config.yml" />
<em>Centroid box representation on right, corner representation on left.</em></p>

<h2 id="how-to-compute-iou">How to compute IOU?</h2>

<p>Using the corner representation it is straightforward to calculate IOU for 2 rectangles.</p>

<p><img src="/urmlblog/images/SSD/IOU_Calculation.jpg" alt="_config.yml" /></p>

<p>Given a pair of rectangular boxes:</p>

<p><img src="/urmlblog/images/SSD/IOU_Box_Calculation.jpg" alt="_config.yml" /></p>

<p>we can find the top-left coordinates of the intersecting bounding box as:</p>

\[xi_{min} = max(x1min, x2min)
yi_{min} = max(y1min, y2min)\]

<p>The bottom-right ccordinates of the intersecting box is</p>

\[xi_{max} = min(x1max, x2max) \\
yi_{max} = min(y1max, y2max)\]

<p>The intersecting area can be easily computed from the coordinates obtained:</p>

\[A_{inter} = max(0, yi_{max} - yi_{min}) * max(0, xi_{max} - xi_{min})\]

<p>If the rectangles donâ€™t overlap then</p>

\[yi_{max}  &lt; yi_{min} \text{  or  }  xi_{max} &lt; xi_{min}\]

<p>in which case $A_{inter} = 0$.</p>

<p>The code below contains helper functions to generate default bounding boxes, find default boxes for which IOU &gt; threshold with ground truth boxes, calculate offsets for training objectives as shown in Eq. \ref{eq:offsets}</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculate_scale_of_default_boxes</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s_max</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span> <span class="n">s_min</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">):</span>
    <span class="s">"""
    m = number_of_feature_maps
    s_k = s_min + (s_max - s_min) * (k - 1)/(m - 1)
    width_k = s_k * sqrt(aspect_ratio)
    height_k = s_k / sqrt(aspect_ratio)
    """</span>
    <span class="k">return</span> <span class="n">s_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">s_max</span> <span class="o">-</span> <span class="n">s_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">generate_default_boxes</span><span class="p">(</span><span class="n">feature_map_shapes</span><span class="p">,</span> <span class="n">number_of_feature_maps</span><span class="p">,</span> <span class="n">aspect_ratios</span><span class="p">):</span>
    <span class="s">"""
    feature map shapes for VGG: [38, 19, 10, 5, 3, 1]
    """</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature_map_shapes</span><span class="p">)</span> <span class="o">==</span> <span class="n">number_of_feature_maps</span><span class="p">,</span> <span class="s">'number of feature maps needs to be {0}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feature_map_shapes</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature_map_shapes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">aspect_ratios</span><span class="p">),</span> <span class="s">'Need aspect ratios for all feature maps'</span>

    <span class="n">prior_boxes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">f_k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">feature_map_shapes</span><span class="p">):</span>
        <span class="n">s_k</span> <span class="o">=</span> <span class="n">calculate_scale_of_default_boxes</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">number_of_feature_maps</span><span class="p">)</span>
        <span class="n">s_k_prime</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_k</span> <span class="o">*</span> <span class="n">calculate_scale_of_default_boxes</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">6</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f_k</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f_k</span><span class="p">):</span>
                <span class="n">cx</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">f_k</span>
                <span class="n">cy</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">f_k</span>
                <span class="n">prior_boxes</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">s_k_prime</span><span class="p">,</span> <span class="n">s_k_prime</span><span class="p">])</span>

                <span class="k">for</span> <span class="n">ar</span> <span class="ow">in</span> <span class="n">aspect_ratios</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                    <span class="c1"># height, width for numpy
</span>                    <span class="n">prior_boxes</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">s_k</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ar</span><span class="p">),</span> <span class="n">s_k</span><span class="o">/</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ar</span><span class="p">)])</span>

    <span class="n">prior_boxes</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">prior_boxes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tf</span><span class="p">.</span><span class="n">clip_by_value</span><span class="p">(</span><span class="n">prior_boxes</span><span class="p">,</span> <span class="n">clip_value_min</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">clip_value_max</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">)</span>


<span class="c1"># Adapted from https://gist.github.com/escuccim/d0be49ccfc6084cdc784a67339f130dd
</span><span class="k">def</span> <span class="nf">box_overlap_iou</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">):</span>
    <span class="s">"""
    Args:
        boxes: shape (total boxes, x_min, y_min, x_max, y_max)
        gt_boxes: shape (1, total label, x_min  y_min, x_max, y_max)

    Returns:
        Tensor with shape (batch_size, total boxes, total label)
    """</span>
    <span class="n">box_x_min</span><span class="p">,</span> <span class="n">box_y_min</span><span class="p">,</span> <span class="n">box_x_max</span><span class="p">,</span> <span class="n">box_y_max</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">gt_boxes_x_min</span><span class="p">,</span> <span class="n">gt_boxes_y_min</span><span class="p">,</span> <span class="n">gt_boxes_x_max</span><span class="p">,</span> <span class="n">gt_boxes_y_max</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="n">gt_boxes</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># From https://www.tensorflow.org/api_docs/python/tf/transpose
</span>    <span class="n">intersection_x_min</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">box_x_min</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">gt_boxes_x_min</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
    <span class="n">intersection_y_min</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">box_y_min</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">gt_boxes_y_min</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="n">intersection_x_max</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">box_x_max</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">gt_boxes_x_max</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
    <span class="n">intersection_y_max</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">box_y_max</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">gt_boxes_y_max</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># need to take care of boxes that don't overlap at all
</span>    <span class="n">intersection_area</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">intersection_x_max</span> <span class="o">-</span> <span class="n">intersection_x_min</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">tf</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">intersection_y_max</span> <span class="o">-</span> <span class="n">intersection_y_min</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">boxes_areas</span> <span class="o">=</span> <span class="p">(</span><span class="n">box_x_max</span> <span class="o">-</span> <span class="n">box_x_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">box_y_max</span> <span class="o">-</span> <span class="n">box_y_min</span><span class="p">)</span>
    <span class="n">gt_box_areas</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_boxes_x_max</span> <span class="o">-</span> <span class="n">gt_boxes_x_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gt_boxes_y_max</span> <span class="o">-</span> <span class="n">gt_boxes_y_min</span><span class="p">)</span>

    <span class="n">union</span> <span class="o">=</span> <span class="p">(</span><span class="n">boxes_areas</span> <span class="o">+</span> <span class="n">tf</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">gt_box_areas</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">-</span> <span class="n">intersection_area</span>

    <span class="k">return</span> <span class="n">tf</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">intersection_area</span> <span class="o">/</span> <span class="n">union</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">match_priors_with_gt</span><span class="p">(</span><span class="n">prior_boxes</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">gt_labels</span><span class="p">,</span> <span class="n">number_of_labels</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">):</span>
    
    <span class="s">"""
    prior boxes: (1, number of default boxes, c_x, c_y, w, h)
    boxes: shape (total boxes, x_min, y_min, x_max, y_max)
    gt_boxes: (1, number of labels, x_min, y_min, x_max, y_max)
    gt_labels: (1, 1 label per each gt box)

    0 is background, so the gt_labels is the number of labels in the dataset + 1
    class 0 is reserved.
    """</span>

    <span class="c1"># number of rows for the IOU map the is the number of gt_boxes
</span>    <span class="n">IOU_map</span> <span class="o">=</span> <span class="n">box_overlap_iou</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">)</span>

    <span class="c1"># convert ground boxes labels to box label format
</span>    <span class="n">gt_box_label</span> <span class="o">=</span> <span class="n">convert_to_centre_dimensions_form</span><span class="p">(</span><span class="n">gt_boxes</span><span class="p">)</span>

    <span class="c1"># select the box with the highest IOU
</span>    <span class="n">highest_overlap_idx</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">IOU_map</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">highest_overlap_idx</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">highest_overlap_idx</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nb">range</span><span class="p">(</span><span class="n">IOU_map</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">highest_overlap_idx_map</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">equal</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">highest_overlap_idx</span><span class="p">)),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">IOU_map</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">highest_overlap_idx_map</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">tf</span><span class="p">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">IOU_map</span><span class="p">)</span>

    <span class="c1"># find the column idx with the highest IOU at each row
</span>    <span class="n">max_IOU_idx_per_row</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">IOU_map</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># find the max value per row
</span>    <span class="n">max_IOU_per_row</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">reduce_max</span><span class="p">(</span><span class="n">IOU_map</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># threshold IOU
</span>    <span class="n">max_IOU_above_threshold</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">greater</span><span class="p">(</span><span class="n">max_IOU_per_row</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    
    <span class="c1"># map the gt boxes to the prior boxes with the highest overlap
</span>    <span class="n">gt_box_label_map</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="n">gt_box_label</span><span class="p">,</span> <span class="n">max_IOU_idx_per_row</span><span class="p">,</span> <span class="n">batch_dims</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># get the offset, offcet (delta_cx, delta_cy, delta_width, delta_height)
</span>    <span class="n">gt_box_label_map_offsets</span> <span class="o">=</span> <span class="n">calculate_offset_from_gt</span><span class="p">(</span><span class="n">gt_box_label_map</span><span class="p">,</span> <span class="n">prior_boxes</span><span class="p">)</span>
    <span class="c1"># remove from gt_boxes_map where overlap with prior boxes is less than 0.5
</span>    <span class="n">gt_boxes_map_offset_suppressed</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">where</span><span class="p">(</span> <span class="n">tf</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">max_IOU_above_threshold</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>  
                                        <span class="n">gt_box_label_map_offsets</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gt_box_label_map</span><span class="p">))</span>
    <span class="c1"># add a positive condition column for the localization loss
</span>    <span class="n">max_IOU_above_threshold_expand</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">max_IOU_above_threshold</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">max_IOU_above_threshold_expand</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">max_IOU_above_threshold_expand</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">gt_boxes_map_offset_suppressed_with_pos_cond</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">concat</span><span class="p">([</span>  <span class="n">gt_boxes_map_offset_suppressed</span><span class="p">,</span> 
                                                                <span class="n">max_IOU_above_threshold_expand</span> <span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>


    <span class="n">gt_labels_map</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="n">gt_labels</span><span class="p">,</span> <span class="n">max_IOU_idx_per_row</span><span class="p">,</span> <span class="n">batch_dims</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># suppress the label where IOU with the gt boxes is &lt; 0.5
</span>    <span class="n">gt_labels_map_suppressed</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">where</span><span class="p">(</span> <span class="n">max_IOU_above_threshold</span><span class="p">,</span> 
                                        <span class="n">gt_labels_map</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gt_labels_map</span><span class="p">))</span>
    <span class="n">gt_labels_one_hot_encoded</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">one_hot</span><span class="p">(</span><span class="n">gt_labels_map_suppressed</span><span class="p">,</span> <span class="n">number_of_labels</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gt_boxes_map_offset_suppressed_with_pos_cond</span><span class="p">,</span> <span class="n">gt_labels_one_hot_encoded</span>

<span class="k">def</span> <span class="nf">calculate_offset_from_gt</span><span class="p">(</span><span class="n">gt_boxes_mapped_to_prior</span><span class="p">,</span> <span class="n">prior_boxes</span><span class="p">):</span>
    <span class="n">prior_boxes</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">prior_boxes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">g_j_cx</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">gt_boxes_mapped_to_prior</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">prior_boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">prior_boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">g_j_cy</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">gt_boxes_mapped_to_prior</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">prior_boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">prior_boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">g_j_w</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">gt_boxes_mapped_to_prior</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">prior_boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">g_j_h</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">gt_boxes_mapped_to_prior</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="n">prior_boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">])</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">concat</span><span class="p">(</span> <span class="p">[</span> <span class="n">g_j_cx</span><span class="p">,</span> <span class="n">g_j_cy</span><span class="p">,</span> <span class="n">g_j_w</span><span class="p">,</span> <span class="n">g_j_h</span> <span class="p">]</span> <span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tf</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">perm</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">convert_to_box_form</span><span class="p">(</span><span class="n">boxes</span><span class="p">):</span>
    <span class="s">"""
    Input:
        (number_of_labels, c_x, c_y, width, height)
    Output:
        (number_of_labels, x_min, y_min, x_max, y_max)
    """</span>

    <span class="n">box_coordinates</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">concat</span><span class="p">([</span>   <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> 
                                    <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">],</span> 
                                    <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tf</span><span class="p">.</span><span class="n">clip_by_value</span><span class="p">(</span><span class="n">box_coordinates</span><span class="p">,</span> <span class="n">clip_value_min</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">clip_value_max</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">convert_to_centre_dimensions_form</span><span class="p">(</span><span class="n">boxes</span><span class="p">):</span>
    <span class="s">"""
    Input:
        boxes: (1, number_of_labels, x_min, y_min, x_max, y_max)
    Output:
        (1, number_of_labels, c_x, c_y, width, height)
    """</span>

    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">concat</span><span class="p">([</span>
                <span class="p">[</span>
                        <span class="p">(</span><span class="n">boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> 
                        <span class="p">(</span><span class="n">boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span>
                        <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">]],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># need the output in the same format as input, could be imporived
</span>    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">tf</span><span class="p">.</span><span class="n">clip_by_value</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">clip_value_min</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">clip_value_max</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="setting-up-the-data-generation-pipeline">Setting up the Data Generation Pipeline</h2>

<p>To train the model we need to setup a data generation pipeline. There is no one best way of encoding your data for the training process. I decided to split the data into two parts, one part encodes the default box offsets and the second part encodes the labels. Using this format also allows me to right seperate loss functions for the default box offset regression and for the confidence loss.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DataGenerator</span><span class="p">(</span><span class="n">keras</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">Sequence</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_IDs</span><span class="p">,</span>
                <span class="n">label_folder_path</span><span class="p">,</span>
                <span class="n">image_folder_path</span><span class="p">,</span> 
                <span class="n">prior_boxes</span><span class="p">,</span>
                <span class="n">prior_boxes_point_form</span><span class="p">,</span>
                <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> 
                <span class="n">n_classes</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> 
                <span class="n">image_height</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
                <span class="n">image_width</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
                <span class="n">normalize</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
                <span class="n">shuffle</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
                <span class="n">image_extension</span> <span class="o">=</span> <span class="s">'.png'</span><span class="p">,</span>
                <span class="n">training</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">list_IDs</span> <span class="o">=</span> <span class="n">list_IDs</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n_classes</span> <span class="o">=</span> <span class="n">n_classes</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">shuffle</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">label_folder_path</span> <span class="o">=</span> <span class="n">label_folder_path</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">image_folder_path</span> <span class="o">=</span> <span class="n">image_folder_path</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">prior_boxes</span> <span class="o">=</span> <span class="n">prior_boxes</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">prior_boxes_point_form</span> <span class="o">=</span> <span class="n">prior_boxes_point_form</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">image_height</span> <span class="o">=</span> <span class="n">image_height</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">image_width</span> <span class="o">=</span> <span class="n">image_width</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">image_extension</span> <span class="o">=</span> <span class="n">image_extension</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">training</span> <span class="o">=</span> <span class="n">training</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">on_epoch_end</span><span class="p">()</span>

        <span class="s">"""
        Inputs:
            list_IDs: name of files used to look data in label_folder_path and image_folder_path
            label_folder_path: path to where labels are stored, need to be in .txt format
            image_folder_path: path to where images are stored, need to be in png
            prior_boxes: precalculated prior boxes in (c_x, c_y, w, h)
            prior_boxes_point_form: precomputed prior boxes in (x_min, y_min, x_max, y_max)
            batch_size: int
            n_classes: number of classes in the dataset, don't include background

        """</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">list_IDs</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">batch_size</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">index</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">batch_size</span><span class="p">:(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">batch_size</span><span class="p">]</span>

        <span class="n">list_IDs_temp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">list_IDs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">__data_generation</span><span class="p">(</span><span class="n">list_IDs_temp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">on_epoch_end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">list_IDs</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">shuffle</span><span class="p">:</span>
            <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">indexes</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">__data_generation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_IDs_temp</span><span class="p">):</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="p">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">image_height</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">image_width</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">y_label</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">y_loc</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_IDs_temp</span><span class="p">):</span>
            <span class="n">image</span><span class="p">,</span> <span class="n">labelled_gt_box_coords</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span>  <span class="n">file_name</span><span class="p">,</span> 
                                        <span class="bp">self</span><span class="p">.</span><span class="n">image_folder_path</span><span class="p">,</span> 
                                        <span class="bp">self</span><span class="p">.</span><span class="n">label_folder_path</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="p">.</span><span class="n">image_extension</span>
                                     <span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">training</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
                    <span class="n">image</span><span class="p">,</span> <span class="n">labelled_gt_box_coords</span> <span class="o">=</span> <span class="n">returnPatches</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labelled_gt_box_coords</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
                    <span class="n">image</span><span class="p">,</span> <span class="n">labelled_gt_box_coords</span> <span class="o">=</span> <span class="n">horizontalFlipImageAndLabels</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labelled_gt_box_coords</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.8</span><span class="p">:</span>
                    <span class="n">image</span><span class="p">,</span> <span class="n">labelled_gt_box_coords</span> <span class="o">=</span> <span class="n">verticalFlipImageAndLabels</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labelled_gt_box_coords</span><span class="p">)</span>

            <span class="c1"># take care of images with no labels
</span>            <span class="c1"># if no label then the whole image is a background
</span>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labelled_gt_box_coords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">labelled_gt_box_coords</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">image</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>

            <span class="n">image</span><span class="p">,</span> <span class="n">labelled_gt_box_coords</span> <span class="o">=</span> <span class="n">resize_images_and_labels</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labelled_gt_box_coords</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">image_height</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">image_width</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">normalize</span><span class="p">:</span>
                <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,]</span> <span class="o">=</span> <span class="n">image</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">image_width</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,]</span> <span class="o">=</span> <span class="n">image</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">image_width</span>

            <span class="n">labelled_gt_box_coords_normallized</span> <span class="o">=</span> <span class="n">label_dimensions_normalized</span><span class="p">(</span><span class="n">labelled_gt_box_coords</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">image_height</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">image_width</span><span class="p">)</span>

            <span class="n">gt_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labelled_gt_box_coords_normallized</span><span class="p">]</span>
            <span class="n">gt_boxes_normalized</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labelled_gt_box_coords_normallized</span><span class="p">]</span>
            
            <span class="n">offset</span><span class="p">,</span> <span class="n">one_hot_encoded_label</span> <span class="o">=</span> <span class="n">match_priors_with_gt</span><span class="p">(</span>   
                                                            <span class="bp">self</span><span class="p">.</span><span class="n">prior_boxes</span><span class="p">,</span> 
                                                            <span class="bp">self</span><span class="p">.</span><span class="n">prior_boxes_point_form</span><span class="p">,</span> 
                                                            <span class="n">tf</span><span class="p">.</span><span class="n">constant</span><span class="p">([</span><span class="n">gt_boxes_normalized</span><span class="p">]),</span> 
                                                            <span class="n">tf</span><span class="p">.</span><span class="n">constant</span><span class="p">([</span><span class="n">gt_labels</span><span class="p">]),</span> 
                                                            <span class="n">number_of_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">n_classes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> 
                                                            <span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">y_label</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">y_label</span> <span class="o">=</span> <span class="n">one_hot_encoded_label</span>
                <span class="n">y_loc</span> <span class="o">=</span> <span class="n">offset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y_label</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">concat</span><span class="p">([</span><span class="n">y_label</span><span class="p">,</span> <span class="n">one_hot_encoded_label</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">y_loc</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">concat</span><span class="p">([</span><span class="n">y_loc</span><span class="p">,</span> <span class="n">offset</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="p">[</span><span class="n">y_loc</span><span class="p">,</span> <span class="n">y_label</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="implementing-ssd-loss">Implementing SSD Loss</h2>

<p>Once we have matched the ground truth boxes with the default boxes. Most of the default boxes will end up being negatives. As a result, the labels will end up being significantly imbalanced. To deal with this imbalance, we use a technique called negative mining. Instead of using all of the negative training examples we sort the softmax confidence metric for each default box and pick the top ones so that the ratio between negatives and positive is at most 3:1.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SSDLoss</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">negative_mining_ratio</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">negative_mining_ratio</span> <span class="o">=</span> <span class="n">negative_mining_ratio</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="c1"># From https://github.com/pierluigiferrari/ssd_keras/blob/master/keras_loss_function/keras_ssd_loss.py
</span>    <span class="k">def</span> <span class="nf">smooth_L1_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
        <span class="s">'''
        Compute smooth L1 loss, see references.
        Arguments:
            y_true (nD tensor): A TensorFlow tensor of any shape containing the ground truth data.
                In this context, the expected tensor has shape `(batch_size, #boxes, 4)` and
                contains the ground truth bounding box coordinates, where the last dimension
                contains `(xmin, xmax, ymin, ymax)`.
            y_pred (nD tensor): A TensorFlow tensor of identical structure to `y_true` containing
                the predicted data, in this context the predicted bounding box coordinates.
        Returns:
            The smooth L1 loss, a nD-1 Tensorflow tensor. In this context a 2D tensor
            of shape (batch, n_boxes_total).
        References:
            https://arxiv.org/abs/1504.08083
        '''</span>
        <span class="n">absolute_loss</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span>
        <span class="n">square_loss</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">l1_loss</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">less</span><span class="p">(</span><span class="n">absolute_loss</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">square_loss</span><span class="p">,</span> <span class="n">absolute_loss</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tf</span><span class="p">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">l1_loss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># From https://github.com/pierluigiferrari/ssd_keras/blob/master/keras_loss_function/keras_ssd_loss.py
</span>    <span class="k">def</span> <span class="nf">log_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
        <span class="s">'''
        Compute the softmax log loss.
        Arguments:
            y_true (nD tensor): A TensorFlow tensor of any shape containing the ground truth data.
                In this context, the expected tensor has shape (batch_size, #boxes, #classes)
                and contains the ground truth bounding box categories.
            y_pred (nD tensor): A TensorFlow tensor of identical structure to `y_true` containing
                the predicted data, in this context the predicted bounding box categories.
        Returns:
            The softmax log loss, a nD-1 Tensorflow tensor. In this context a 2D tensor
            of shape (batch, n_boxes_total).
        '''</span>
        <span class="c1"># Make sure that `y_pred` doesn't contain any zeros (which would break the log function)
</span>        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="mf">1e-15</span><span class="p">)</span>
        <span class="c1"># Compute the log loss
</span>        <span class="n">log_loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">tf</span><span class="p">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">y_true</span> <span class="o">*</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">y_pred</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">log_loss</span>

    <span class="k">def</span> <span class="nf">localization_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">actual_deltas</span><span class="p">,</span> <span class="n">pred_delta</span><span class="p">):</span>
        <span class="s">"""
        input:
            actual_deltas: (batch_size, number of prior boxes, [delta_cx, delta_cy, delta_w, delta_h, pos_cond])
            pred_delta = (batch_size, number of prior boxes, [delta_cx, delta_cy, delta_w, delta_h])

        outputs:
            loc_loss: Huber loss over all prior boxes with IOU &gt; threshold (defined elsewhere)
            over ground label boxes
        """</span>

        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pred_delta</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">localization_loss_for_all_priors</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">smooth_L1_loss</span><span class="p">(</span><span class="n">actual_deltas</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">pred_delta</span><span class="p">)</span>

        <span class="n">localization_loss_for_all_priors</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">localization_loss_for_all_priors</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># localization loss is only for default prior boxes with IOU &gt; 0.5 over ground truth boxes
</span>        <span class="n">localization_loss_for_all_priors</span> <span class="o">=</span> <span class="n">localization_loss_for_all_priors</span> <span class="o">*</span> <span class="n">actual_deltas</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">4</span><span class="p">]</span>

        <span class="n">total_pos_boxes</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">actual_deltas</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">4</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># If an image has no labels, the loc loss for that image should be 0.
</span>        <span class="n">no_label_mask</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">reduce_any</span><span class="p">(</span> <span class="n">tf</span><span class="p">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">total_pos_boxes</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">0.</span><span class="p">)),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">)</span>

        <span class="n">total_pos_boxes</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">total_pos_boxes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="n">total_pos_boxes</span><span class="p">)</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">tf</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">no_label_mask</span><span class="p">]),</span> 
                                                    <span class="n">localization_loss_for_all_priors</span> <span class="o">/</span> <span class="n">total_pos_boxes</span><span class="p">,</span> 
                                                    <span class="n">tf</span><span class="p">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">0.</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">tf</span><span class="p">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">confidence_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">actual_labels</span><span class="p">,</span> <span class="n">pred_labels</span><span class="p">):</span>
        <span class="s">"""
        inputs:
            actual_labels = (batch_size, number of prior boxes, total labels)
            pred_labels = (batch_size, number of prior boxes, total labels)
        
        outputs:
            conf_loss = loss per class
        """</span>

        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pred_labels</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">confidence_loss_for_all</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">log_loss</span><span class="p">(</span><span class="n">actual_labels</span><span class="p">,</span> <span class="n">pred_labels</span><span class="p">)</span>

        <span class="n">confidence_loss_for_all</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">confidence_loss_for_all</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">pos_cond</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">reduce_any</span><span class="p">(</span> <span class="n">tf</span><span class="p">.</span><span class="n">equal</span><span class="p">(</span><span class="n">actual_labels</span><span class="p">[...,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">tf</span><span class="p">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">pos_mask</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">pos_cond</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">total_pos_boxes</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">pos_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">pos_loss</span> <span class="o">=</span> <span class="n">pos_mask</span> <span class="o">*</span> <span class="n">confidence_loss_for_all</span>

        <span class="c1"># hard negative mining
</span>        <span class="c1"># set positive cases to 0
</span>        <span class="n">neg_cond</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">reduce_any</span><span class="p">(</span> <span class="n">tf</span><span class="p">.</span><span class="n">equal</span><span class="p">(</span><span class="n">actual_labels</span><span class="p">[...,</span> <span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">tf</span><span class="p">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="n">confidence_loss_for_all</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">neg_cond</span><span class="p">,</span> <span class="n">confidence_loss_for_all</span><span class="p">,</span> 
                                        <span class="n">tf</span><span class="p">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
                                        <span class="p">)</span>
        
        <span class="c1"># If there are no positive positive boxes in the select top k
</span>        <span class="n">neg_boxes_for_empty_images</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total_neg_boxes</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">total_pos_boxes</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">negative_mining_ratio</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">no_neg_boxes_mask</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">total_neg_boxes</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">constant</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">total_neg_boxes</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">no_neg_boxes_mask</span><span class="p">,</span> <span class="n">total_neg_boxes</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">constant</span><span class="p">(</span><span class="n">neg_boxes_for_empty_images</span><span class="p">))</span>

        <span class="c1"># sort by positive example
</span>        <span class="n">loss_sorted_indices</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">confidence_loss_for_all</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">"DESCENDING"</span><span class="p">)</span>
        <span class="n">loss_sorted_rank</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">loss_sorted_indices</span><span class="p">)</span>

        <span class="n">neg_mining_cond</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">less</span><span class="p">(</span><span class="n">loss_sorted_rank</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">total_neg_boxes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">neg_mining_mask</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">neg_mining_cond</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">neg_loss</span> <span class="o">=</span> <span class="n">neg_mining_mask</span> <span class="o">*</span> <span class="n">confidence_loss_for_all</span>
        <span class="c1"># total_boxes = total_pos_boxes + tf.cast(total_neg_boxes, tf.float32)
</span>        <span class="n">total_pos_boxes</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">total_pos_boxes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="n">total_pos_boxes</span><span class="p">)</span>
        <span class="n">total_loss</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos_loss</span> <span class="o">+</span> <span class="n">neg_loss</span><span class="p">)</span> <span class="o">/</span> <span class="n">tf</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">total_pos_boxes</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tf</span><span class="p">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">total_loss</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="model-training-results">Model Training Results</h2>

<p>I trained the model for a couple of thousand epochs on the VOC2012 datasets. The performance of the model is a bit hit and miss on real out-of-sample dataset as you can see from the images below:</p>

<p><img src="/urmlblog/images/SSD/cat_and_dog.png" alt="_config.yml" /></p>

<p><img src="/urmlblog/images/SSD/aeroplane.png" alt="_config.yml" /></p>

<p><img src="/urmlblog/images/SSD/khabib-dustin.png" alt="_config.yml" /></p>

<p><img src="/urmlblog/images/SSD/woman_with_cat.png" alt="_config.yml" /></p>

<p>My goal is to use this as a starting point for a larger project I am working on so I didnâ€™t train the model further. I just wanted to make sure that the model is implemented correctly, I am sure if I train for a longer periof of time I will see an improvement in performance.</p>

<p>To learn more check out my <a href="https://github.com/usmanr149/SSDModel" target="_blank">github repo</a> here for the complete implementation.</p>

    



<div class="post-tags">
  
    
    <a href="/urmlblog/tags.html#anchor-boxes">
    
      <span class="icon">
        <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
      </span>&nbsp;<span class="tag-name">Anchor Boxes</span>
    </a>
  
    
    <a href="/urmlblog/tags.html#computer-vision">
    
      <span class="icon">
        <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
      </span>&nbsp;<span class="tag-name">Computer Vision</span>
    </a>
  
    
    <a href="/urmlblog/tags.html#ssd">
    
      <span class="icon">
        <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
      </span>&nbsp;<span class="tag-name">SSD</span>
    </a>
  
</div>
  </div>

  
  <section class="comments">
    <h2>Comments</h2>
    
  <div id="disqus_thread">
    <button class="disqus-load" onClick="loadDisqusComments()">
      Load Comments
    </button>
  </div>
  <script>

  /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW
  *  TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT:s
  *  https://disqus.com/admin/universalcode/#configuration-variables
  */
  var disqus_config = function () {
    this.page.url = "http://localhost:4000/urmlblog/computer%20vision/2022/09/10/Implenting-SSD-TF2.html";
    this.page.identifier = "" ||
                           "http://localhost:4000/urmlblog/computer%20vision/2022/09/10/Implenting-SSD-TF2.html";
  }
  function loadDisqusComments() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//https-usmanr149-github-io-urmlblog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  }
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a>.
  </noscript>



  </section>

  <section class="related">
  <h2>Related Posts</h2>
  <ul class="posts-list">
    
      <li>
        <h3>
          <a href="/urmlblog/computer%20vision/2022/09/09/SSD-Anchorboxes.html">
            Generating Anchor Boxes
            <small>09 Sep 2022</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/urmlblog/time%20series/2021/04/30/2021-4-30-AR-model.html">
            Autoregressive Model -- Properties of AR(1) Model
            <small>30 Apr 2021</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/urmlblog/stocks/2020/10/01/stock-movement-prediction.html">
            Training a Machine Learning Algorithm to Predict Stock Price Movement
            <small>01 Oct 2020</small>
          </a>
        </h3>
      </li>
    
  </ul>
</section>

</div>

    </main>

    <!-- Optional footer content -->

  </body>
</html>
